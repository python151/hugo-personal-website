<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Emily Miller</title>
    <link>https://www.emilymiller.xyz/post/</link>
    <description>Recent content in Posts on Emily Miller</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2025, Emily Miller &lt;br /&gt; Hosted with &lt;a href=&#39;https://tardisproject.uk&#39;&gt;Tardis&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 17 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://www.emilymiller.xyz/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to host a CTF</title>
      <link>https://www.emilymiller.xyz/post/how_to_host_a_ctf/</link>
      <pubDate>Sun, 17 Aug 2025 00:00:00 +0000</pubDate>
      
      <guid>https://www.emilymiller.xyz/post/how_to_host_a_ctf/</guid>
      <description>Part 0: Infrastructure In order to run this, you&amp;rsquo;ll need some sort of server (a VM in Azure, AWS, Google Cloud, or a VPS will do just fine for this purpose), and you&amp;rsquo;ll likely want a domain name. If you&amp;rsquo;ve never worked with servers or DNS before, I&amp;rsquo;d recommend reading a bit about DNS and and follow a guide to setup a basic website.
Part 1: Getting your platform up Generally, in the year of our lord 2025, it&amp;rsquo;s relatively easy to get a decent self hosted CTF platform up and running.</description>
    </item>
    
    <item>
      <title>RSA Cheatsheet</title>
      <link>https://www.emilymiller.xyz/post/basic_rsa/</link>
      <pubDate>Thu, 05 Jun 2025 00:00:00 +0000</pubDate>
      
      <guid>https://www.emilymiller.xyz/post/basic_rsa/</guid>
      <description>Links:
https://github.com/mohamm4c/Attacks-On-RSA-using-Python/blob/main/Different_Attacks_on_RSA_system-Final.pdf https://www.ams.org/notices/199902/boneh.pdf https://eprint.iacr.org/2012/064.pdf Cryptosystem:
Pick some e (usually 0x10001), and large N. These are made public. Now, pick some d, s.t. for any given m, $(m^e)^d=m \mod N$. Also, we call the ciphertext $ct=m^e \mod N$ In practice we usually keep e constant, and pick two primes $p,q$, and saying $N=p*q$, then we can use Euler&amp;rsquo;s theorem and some properties of Euler&amp;rsquo;s totient function ($\phi(n)$), to show that $\phi(N)=(p-1)*(q-1)$, and hence $d = e^{-1} \mod \phi(N)$, which is trivial to calculate.</description>
    </item>
    
    <item>
      <title>Crash course GDB</title>
      <link>https://www.emilymiller.xyz/post/gdb_basics/</link>
      <pubDate>Tue, 11 Feb 2025 00:00:00 +0000</pubDate>
      
      <guid>https://www.emilymiller.xyz/post/gdb_basics/</guid>
      <description>The use of debuggers like GDB is a fundamental skill in binary exploitation and reverse engineering, but can be difficult to grasp at first. Here&amp;rsquo;s a &amp;ldquo;Crash course&amp;rdquo; GDB.
What is GDB? GDB stands for the GNU Debugger, so put simply, it&amp;rsquo;s a FOSS (Free and Open Source Software) debugging tool. At its most basic level, it allows you to run a program, set breakpoints, and be able to look &amp;ldquo;inside&amp;rdquo; the program at each of those breakpoints, including raw memory (looking at the stack, heap, current instructions, etc.</description>
    </item>
    
    <item>
      <title>How to: Basic buffer overflows without stack protections</title>
      <link>https://www.emilymiller.xyz/post/how_to_basic_buffer_overflows/</link>
      <pubDate>Mon, 10 Feb 2025 00:00:00 +0000</pubDate>
      
      <guid>https://www.emilymiller.xyz/post/how_to_basic_buffer_overflows/</guid>
      <description>Kind of starting a little basic, but what is a buffer overflow? Effectively, when the program is expecting a certain amount of data to be written, and more data than that gets written, overflowing the buffer. When done on the stack (the most basic case), this is often called stack smashing (as seen in the amazing stack canary message &amp;ldquo;**** stack smashing detected ****&amp;rdquo;).
For instance, if our memory looks something like below:</description>
    </item>
    
    <item>
      <title>How to: Buffer overflows with PIE, Canaries, and NX Bit</title>
      <link>https://www.emilymiller.xyz/post/how_to_buffer_overflows_with_stack_protections/</link>
      <pubDate>Mon, 10 Feb 2025 00:00:00 +0000</pubDate>
      
      <guid>https://www.emilymiller.xyz/post/how_to_buffer_overflows_with_stack_protections/</guid>
      <description>What stack protections are we talking about? Here we&amp;rsquo;re only talking about bypassing PIE, Stack Canaries, and NX Bit, because these are found in almost every binary compiled nowadays and you will be expected to know this in any basic binary exploitation exercise.
You speak all these words, woman, but I understand not. What&amp;rsquo;s PIE?
PIE stands for Position Independent Executable, and all it means is that it can get loaded into different positions in memory randomly at runtime, which makes exploitation a bit harder.</description>
    </item>
    
    <item>
      <title>First Post</title>
      <link>https://www.emilymiller.xyz/post/first_post/</link>
      <pubDate>Sun, 09 Feb 2025 00:00:00 +0000</pubDate>
      
      <guid>https://www.emilymiller.xyz/post/first_post/</guid>
      <description>Hey, I have this now! ðŸŽ‰ Excited to start sharing my work and ideas here. Stay tuned for more updates!</description>
    </item>
    
  </channel>
</rss>
